# -*- coding: utf-8 -*-
"""Image Loading.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D63JPvWbGg5QcCgFalLSMDQDhNUzihiO

# Image Loading

This Notebook is designed to demonstrate how to handle image loading for computer vision tasks, focusing particularly on a binary classification problem. The procedure includes loading, resizing, displaying, and analyzing image datasets to provide insights into their characteristics.

## Overview of the Notebook

### 1. Environment Setup and Library Imports
We begin by setting up our environment and importing necessary libraries:
- `os` for directory manipulation.
- `cv2` (OpenCV) for image operations.
- `pandas` for data handling.
- `matplotlib` for visualizations.

### 2. Functions for Image Loading and Processing
- `load_images`: Loads images from specified subdirectories (representing classes) maintaining their original size.
- `load_and_resize_images`: Extends `load_images` to resize each image to a uniform dimension (1200x1200 pixels), essential for consistent input size in computer vision algorithms.

### 3. Displaying Images
- The notebook contains two versions of the `display_images` function. The first displays a specified number of images directly. The second ensures balanced visualization by shuffling and selectively displaying an equal number of images from each category (cats and dogs).

### 4. Describing the Image Dataset
- Initially, we describe basic dataset characteristics such as the number of images and the dimensions of the first image.
- An enhanced version of `describe_images` identifies and reports all unique image dimensions within the dataset, helping in understanding the diversity in image sizes and necessary preprocessing.

### 5. Execution and Visualization
- Functions are executed to load images from training and testing directories, display subsets of these images, and describe the datasets' characteristics.
- The process is repeated with resized images to demonstrate the impact of resizing on uniformity and dataset consistency.

## Conclusion

This notebook provides a practical approach to managing image data, emphasizing essential preprocessing steps for preparing data for machine learning models in computer vision. The detailed implementations and direct outputs equip users with a comprehensive toolkit for any image classification tasks using Google Colab.
"""

import os
import cv2
import pandas as pd
from matplotlib import pyplot as plt
import random

"""https://www.kaggle.com/datasets/samuelcortinhas/cats-and-dogs-image-classification?resource=download"""

base_dir = '/path/do/the/image/datasets/'

# This function loads images in their original size
def load_images(base_dir, subfolder):
    classes = ['cats', 'dogs']  # Subdirectories for classes
    images = []
    for cls in classes:
        class_dir = os.path.join(base_dir, subfolder, cls)
        for filename in os.listdir(class_dir):
            img_path = os.path.join(class_dir, filename)
            img = cv2.imread(img_path)
            if img is not None:
                images.append((img, cls))
    return images

# Function to load images and resize them to the fixed size
def load_and_resize_images(base_dir, subfolder, size=(150, 150)):
    classes = ['cats', 'dogs']
    images = []
    for cls in classes:
        class_dir = os.path.join(base_dir, subfolder, cls)
        for filename in os.listdir(class_dir):
            img_path = os.path.join(class_dir, filename)
            img = cv2.imread(img_path)
            if img is not None:
                # Resize image to the specified size
                resized_img = cv2.resize(img, size, interpolation = cv2.INTER_AREA)
                images.append((resized_img, cls))
    return images

# Function to display images
def display_images(image_tuples, number=5):
    plt.figure(figsize=(20, 10))
    for i, (image, label) in enumerate(image_tuples[:number]):
        plt.subplot(1, number, i+1)
        plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        plt.title(label)
    plt.show()

# Function to display images
def display_images(image_tuples, number=6):
    plt.figure(figsize=(20, 10))
    # Shuffle the list to get a random sample of images
    random.shuffle(image_tuples)
    selected_images = []

    # Attempt to select an equal number of images from each label
    count_cats = count_dogs = number // 2

    for img, label in image_tuples:
        if label == 'cats' and count_cats > 0:
            selected_images.append((img, label))
            count_cats -= 1
        elif label == 'dogs' and count_dogs > 0:
            selected_images.append((img, label))
            count_dogs -= 1
        if len(selected_images) == number:
            break

    # Display the selected images
    for i, (image, label) in enumerate(selected_images):
        plt.subplot(1, number, i + 1)
        plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        plt.title(label)
    plt.show()

# Function to describe images
def describe_images(images):
    print("Number of images:", len(images))
    if images:
        img_shape = images[0][0].shape
        print("Image dimensions:", img_shape)

# Function to describe images
# Returns dimensions of all images
def describe_images(images):
    print("Number of images:", len(images))
    unique_dimensions = set()
    for img, label in images:
        unique_dimensions.add(img.shape)
    print("Unique image dimensions:", unique_dimensions)

# Load images from train and test directories
train_images = load_images(base_dir, 'train')
test_images = load_images(base_dir, 'test')
print(f'Loaded {len(train_images)} training images and {len(test_images)} testing images')

display_images(train_images + test_images)

describe_images(train_images + test_images)

train_images = load_and_resize_images(base_dir, 'train')
test_images = load_and_resize_images(base_dir, 'test')
print(f'Loaded {len(train_images)} training images and {len(test_images)} testing images')

display_images(train_images + test_images)

describe_images(train_images + test_images)

